

----QUIT----(13 August 2023 19:14:09) CuisUniversity-5981.image priorSource: 5713367!

----STARTUP---- (13 August 2023 19:14:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5981.image!


----QUIT----(13 August 2023 19:14:10) CuisUniversity-5981.image priorSource: 10197065!

----STARTUP---- (18 September 2023 20:36:46) as /home/clinux01/Escritorio/linux64/CuisUniversity-5981.image!


----End fileIn of /home/clinux01/Escritorio/linux64/1erParcial/ISW1-2022-1C-Parcial-1.st----!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'avb 9/18/2023 20:52:14'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'avb 9/18/2023 20:52:14'!
PASSED!
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:03:21'!
recorrer: unaColeccion verificando: unaCondicion
	| ix  |
	
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | element |
		element := unaColeccion at: ix.
		self relocate: element after: unaCondicion.
		ix := ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:03:55' prior: 50651396!
recorrer: unaColeccion verificando: unaCondicion
	| ix  |
	
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | car |
		car := unaColeccion at: ix.
		self relocate: car after: unaCondicion.
		ix := ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:04:53' prior: 50650962!
advance: aTimeLapse
	
	| ix cars |
	
	cars := track cars asOrderedCollection.
	^self recorrer: cars verificando: aTimeLapse .
	
	
	"ix := 1.
	[ix <= cars size] whileTrue: [ | car |
		car := cars at: ix.
		self relocate: car after: aTimeLapse.
		ix := ix + 1.
	]"
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:05:01' prior: 50651419!
advance: aTimeLapse
	
	|  cars |
	
	cars := track cars asOrderedCollection.
	^self recorrer: cars verificando: aTimeLapse .
	
	
	"ix := 1.
	[ix <= cars size] whileTrue: [ | car |
		car := cars at: ix.
		self relocate: car after: aTimeLapse.
		ix := ix + 1.
	]"
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:05:07' prior: 50651430!
advance: aTimeLapse
	
	|  cars |
	
	cars := track cars asOrderedCollection.
	^self recorrer: cars verificando: aTimeLapse .
	
	"ix := 1.
	[ix <= cars size] whileTrue: [ | car |
		car := cars at: ix.
		self relocate: car after: aTimeLapse.
		ix := ix + 1.
	]"
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:05:41' prior: 50651408!
recorrer: unaColeccion verificando: unaCondicion
	| ix  |
	"el metodo relocate es para autoss, pero quizas puedo pasar un closure"
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | car |
		car := unaColeccion at: ix.
		self relocate: car after: unaCondicion.
		ix := ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:05:42' prior: 50651452!
recorrer: unaColeccion verificando: unaCondicion
	| ix  |
	"el metodo relocate es para autoss, pero quizas puedo pasar uns closure"
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | car |
		car := unaColeccion at: ix.
		self relocate: car after: unaCondicion.
		ix := ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:06:36'!
recorrer: unaColeccion realizando: unaAccion
	| ix  |
	"el metodo relocate es para autoss, pero quizas puedo pasar uns closure"
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | car |
		car := unaColeccion at: ix.
		unaAccion value.
		ix := ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'avb 9/18/2023 21:06:51' prior: 50651478!
recorrer: unaColeccion realizando: unaAccion
	| ix  |
	"el metodo relocate es para autoss, pero quizas puedo pasar uns closure"
	"cars := track cars asOrderedCollection."
	ix := 1.

	[ix <= unaColeccion size] whileTrue: [ | elem |
		elem := unaColeccion at: ix.
		unaAccion value.
		ix := ix + 1.
	]
! !
!Track methodsFor: 'accessing' stamp: 'avb 9/18/2023 21:07:45' prior: 50651248!
cars
	| allCars ix |
	
	allCars := Set new.
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	].

	^ allCars
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'avb 9/18/2023 21:07:50'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'avb 9/18/2023 21:08:04'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'avb 9/18/2023 21:08:04'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'avb 9/18/2023 21:09:39' prior: 50651503!
cars
	| allCars ix |
	
	allCars := Set new.
	self usar: allCars yRealizar: [allCars addAll: 1].
	"ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	]."

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'avb 9/18/2023 21:11:48'!
usar: allCars yRealizar: unaAccion
	|ix|
	 [allCars addAll: 1].

	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		unaAccion value.
		ix := ix + 1.
	].

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'avb 9/18/2023 21:12:37' prior: 50651700!
usar: unaColeccion yRealizar: unaAccion
	|ix|
	 "[allCars addAll: 1]."

	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		unaAccion value.
		ix := ix + 1.
	].

	
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'avb 9/18/2023 21:13:07'!
ERROR!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'avb 9/18/2023 21:13:07'!
ERROR!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'avb 9/18/2023 21:13:07'!
ERROR!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'avb 9/18/2023 21:13:07'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'avb 9/18/2023 21:13:07'!
PASSED!

FormulaOneCar subclass: #Turbo
	instanceVariableNames: 'car activated timesActivated'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'avb 9/18/2023 21:19:13'!
FormulaOneCar subclass: #Turbo
	instanceVariableNames: 'car activated timesActivated'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

FormulaOneCar subclass: #Turbo
	instanceVariableNames: 'car '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'avb 9/18/2023 21:19:50'!
FormulaOneCar subclass: #Turbo
	instanceVariableNames: 'car'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

FormulaOneCar subclass: #TurboActivado
	instanceVariableNames: 'car'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboActivado category: 'ISW1-2022-1C-Parcial-1' stamp: 'avb 9/18/2023 21:19:57'!
FormulaOneCar subclass: #TurboActivado
	instanceVariableNames: 'car'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRenamed: #Turbo as: #TurboDesactivado stamp: 'avb 9/18/2023 21:20:05'!
Smalltalk renameClassNamed: #Turbo as: #TurboDesactivado!
!TurboActivado methodsFor: 'no messages' stamp: 'avb 9/18/2023 21:20:20'!
dd 
self error: self turboAlreadyActivatedErrorDescription ! !
!TurboActivado methodsFor: 'as yet unclassified' stamp: 'avb 9/18/2023 21:20:36' overrides: 50650872!
activateTurbo
	self error: self turboAlreadyActivatedErrorDescription ! !

!methodRemoval: TurboActivado #dd stamp: 'avb 9/18/2023 21:20:41'!
dd 
self error: self turboAlreadyActivatedErrorDescription !
!TurboDesactivado methodsFor: 'nil' stamp: 'avb 9/18/2023 21:21:08'!
activateTurboTo: unAuto
! !
!TurboDesactivado methodsFor: 'as yet unclassified' stamp: 'avb 9/18/2023 21:21:44' prior: 50651864!
activateTurboTo: unAuto
	(unAuto currentSector) activateTurboTo: unAuto .! !
!TurboDesactivado methodsFor: 'as yet unclassified' stamp: 'avb 9/18/2023 21:22:27' prior: 50651869!
activateTurboTo: unAuto
	^ currentSector activateTurboTo: unAuto .! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'avb 9/18/2023 21:23:05' prior: 50650872!
activateTurbo

	"turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self."

	self subclassResponsibility .! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'avb 9/18/2023 21:23:11'!
FAILURE!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'avb 9/18/2023 21:23:11'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'avb 9/18/2023 21:23:11'!
FAILURE!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'avb 9/18/2023 21:23:11'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'avb 9/18/2023 21:23:11'!
ERROR!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'avb 9/18/2023 21:23:11'!
PASSED!
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:27:28'!
codigosRepetidos

	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:27:59' prior: 50651977!
codigosRepetidos
"sector if none"
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:28:28' prior: 50651987!
codigosRepetidos
"sector if none"
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value.
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:28:41' prior: 50651997!
codigosRepetidos
"sector if none
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value."
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:29:11' prior: 50652014!
codigosRepetidos
"sector if none
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value."
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."

"	position of	
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar)."! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:29:49' prior: 50652031!
codigosRepetidos
"sector if none
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value."
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."

"	position of	
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar)."
	
	" lenght
		| acc ix |

	acc := 0 * kilometer.
	ix := 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector := sectors at: ix.
		acc := acc + sector length.
		ix := ix + 1.		
	].
"! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:30:32' prior: 50652057!
codigosRepetidos
"sector if none
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value."
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."

"	position of	
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar)."
	
	" lenght
		| acc ix |

	acc := 0 * kilometer.
	ix := 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector := sectors at: ix.
		acc := acc + sector length.
		ix := ix + 1.		
	].
"

"cars
	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	].

	^ allCars"! !
!Track methodsFor: 'car position' stamp: 'avb 9/18/2023 21:32:41' prior: 50652089!
codigosRepetidos
"sector if none
	 | ix aBlock |
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector aCar |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value."
	"  put at
		ix := 1.
	sector := sectors at: ix. 
	acc := 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc := acc + sector length.
		ix := ix + 1.
		sector := sectors at: ix.
	]."

"	position of	
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar)."
	
	" lenght
		| acc ix |

	acc := 0 * kilometer.
	ix := 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector := sectors at: ix.
		acc := acc + sector length.
		ix := ix + 1.		
	].
"

"cars
	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	].

	^ allCars"
	
	" includes
		| inc ix sector |
	inc := false.
	ix := 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector := sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc := true]
		ifFalse: [
			ix := ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s := sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix := ix + 1
			]	
		]. 
	^ inc"! !

----End fileIn of /home/clinux01/Escritorio/linux64/Packages/TerseGuide.pck.st----!

----STARTUP---- (13 November 2023 19:39:43) as /home/clinux01/Escritorio/linux64/CuisUniversity-CustomerImporter.image!


----End fileIn of /home/clinux01/Escritorio/linux64/CustomerImporter.st----!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:11' prior: 50650334!
test01Import

	| numberOfCustomers |
	Customer importCustomers.
	
	numberOfCustomers := 2.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:15' prior: 50650594!
test01Import

	| numberOfCustomers |
	
	Customer importCustomers.
	
	numberOfCustomers := 2.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:53' prior: 50650602!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:05:33' prior: 50650610!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:05:35'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:22:56' prior: 50650619!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	"session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	session close."! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:25:02' prior: 50650635!
test01Import
	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:27:12' prior: 50650648!
test01Import

	self importCustomers.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:27:24'!
importCustomers

| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:27:28'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:27:29'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:28:02' prior: 50650693!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'jgv 11/13/2023 20:28:02'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:29:01' prior: 50650689!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:29:04'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:29:05'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:29:25' prior: 50650785!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:30:29' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:30:29' prior: 50650738!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:31:13' prior: 50650798!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:31:32' prior: 50650813!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:31:45'!
PASSED!

!methodRemoval: Customer class #importCustomers stamp: 'jgv 11/13/2023 20:31:56'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:32:06'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:32:07'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:03' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:03' prior: 50650859!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:10' prior: 50650948!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:33:11'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:34:39'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:34:40'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:38:33' prior: 50650850!
test01Import

	| numberOfCustomers customer customers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:38:42' prior: 50651027!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:38:53'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:43:38'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:47:52' prior: 50650984!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:47:55'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:48:14'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:48:15'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:48:57' prior: 50651050!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	
	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:48:57'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:48:58'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:49:54' prior: 50651122!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses equals: 2. 
	
	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:49:55'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:50:02' prior: 50651151!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:50:03'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 20:50:04'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:55:26' prior: 50651179!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.

	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:57:43' prior: 50651209!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.
	self assert: (pepesAddresses anySatisfy: [ :anAddress | anAddress ])
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:58:34' prior: 50651236!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.
	self assert: (pepesAddresses anySatisfy: [ :anAddress | anAddress streetName = 'San Martin'])
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:03:50' prior: 50651265!
test01Import

	| numberOfCustomers customer customers pepesAddresses pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:04:00' prior: 50651295!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:06:31' prior: 50651324!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [] ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:07:08' prior: 50651352!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:10:39' prior: 50651381!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:11:02' prior: 50651411!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:11:37' prior: 50651454!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	self assert:customer addresses includes: pepesFirstAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:14' prior: 50651498!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:35' prior: 50651544!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:52' prior: 50651600!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:14:53'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:16:46' prior: 50651656!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:17:24' prior: 50651716!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:17:25'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:17:54'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:17:55'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:19:51' prior: 50651776!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = 1636] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:19:53'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:21:32'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:21:46'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:21:55'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:22:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:13'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:14'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:15'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:16'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:17'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:19'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:20'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:21'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:25'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:26'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:27'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:29'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:30'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:32'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:34'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:35'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:36'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:37'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:40'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:43'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:44'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:45'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:49'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:51'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:53'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:54'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:55'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:56'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:58'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:23:59'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:00'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:01'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:02'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:03'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:04'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:06'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:09'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:11'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:12'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:24:12'!
ERROR!

----STARTUP---- (13 November 2023 21:24:14) as /home/clinux01/Escritorio/linux64/CuisUniversity-CustomerImporter.image!


!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:24:44'!
TestCase subclass: #ImportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
TestCase subclass: #ImportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
TestCase subclass: #ImportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'NR 6/22/2023 15:23:45'!
test01Import

	Customer importCustomers ! !

!classDefinition: #Address category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Address category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!Address methodsFor: 'province' stamp: 'HAW 5/22/2022 00:19:29'!
province

	^province! !
!Address methodsFor: 'province' stamp: 'HAW 5/22/2022 00:19:29'!
province: aProvince

	province := aProvince
	! !
!Address methodsFor: 'street' stamp: 'HAW 5/22/2022 00:19:29'!
streetName

	^streetName ! !
!Address methodsFor: 'street' stamp: 'HAW 5/22/2022 00:19:29'!
streetName: aStreetName

	streetName := aStreetName ! !
!Address methodsFor: 'street' stamp: 'HAW 5/22/2022 00:19:29'!
streetNumber

	^streetNumber ! !
!Address methodsFor: 'street' stamp: 'HAW 5/22/2022 00:19:29'!
streetNumber: aStreetNumber

	streetNumber := aStreetNumber ! !
!Address methodsFor: 'twon' stamp: 'HAW 5/22/2022 00:19:29'!
town

	^town! !
!Address methodsFor: 'twon' stamp: 'HAW 5/22/2022 00:19:29'!
town: aTown

	town := aTown! !
!Address methodsFor: 'zip code' stamp: 'HAW 5/22/2022 00:19:29'!
zipCode

	^zipCode! !
!Address methodsFor: 'zip code' stamp: 'HAW 5/22/2022 00:19:29'!
zipCode: aZipCode

	zipCode := aZipCode! !

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!Customer methodsFor: 'addresses' stamp: 'HAW 5/22/2022 00:19:29'!
addAddress: anAddress

	addresses add: anAddress ! !
!Customer methodsFor: 'addresses' stamp: 'HAW 5/22/2022 00:19:29'!
addresses

	^ addresses! !
!Customer methodsFor: 'name' stamp: 'HAW 5/22/2022 00:19:29'!
firstName

	^firstName ! !
!Customer methodsFor: 'name' stamp: 'HAW 5/22/2022 00:19:29'!
firstName: aName

	firstName := aName! !
!Customer methodsFor: 'name' stamp: 'HAW 5/22/2022 00:19:29'!
lastName

	^lastName ! !
!Customer methodsFor: 'name' stamp: 'HAW 5/22/2022 00:19:29'!
lastName: aLastName

	lastName := aLastName
! !
!Customer methodsFor: 'identification' stamp: 'HAW 5/22/2022 00:19:29'!
identificationNumber

	^identificationNumber ! !
!Customer methodsFor: 'identification' stamp: 'HAW 5/22/2022 00:19:29'!
identificationNumber: anIdentificationNumber

	identificationNumber := anIdentificationNumber! !
!Customer methodsFor: 'identification' stamp: 'HAW 5/22/2022 00:19:29'!
identificationType

	^identificationType ! !
!Customer methodsFor: 'identification' stamp: 'HAW 5/22/2022 00:19:29'!
identificationType: anIdentificationType

	identificationType := anIdentificationType! !
!Customer methodsFor: 'initialization' stamp: 'HAW 5/22/2022 00:19:29' overrides: 16920235!
initialize

	super initialize.
	addresses := OrderedCollection new.! !

!classDefinition: 'Customer class' category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Customer class
	instanceVariableNames: ''!

!classDefinition: 'Customer class' category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Customer class
	instanceVariableNames: ''!
!Customer class methodsFor: 'importing' stamp: 'NR 6/22/2023 15:24:06'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!classDefinition: #DataBaseSession category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #DataBaseSession category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!DataBaseSession methodsFor: 'transaction management' stamp: 'HAW 5/22/2022 00:19:29'!
beginTransaction

	! !
!DataBaseSession methodsFor: 'transaction management' stamp: 'HAW 5/22/2022 19:17:36'!
commit

	(tables at: Customer ifAbsent: [#()]) do: [ :aCustomer | self persistAddressesOf: aCustomer ]
	! !
!DataBaseSession methodsFor: 'closing' stamp: 'HAW 5/22/2022 00:19:29'!
close

	! !
!DataBaseSession methodsFor: 'persistence - private' stamp: 'HAW 5/22/2022 00:19:29'!
defineIdOf: anObject

	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !
!DataBaseSession methodsFor: 'persistence - private' stamp: 'HAW 5/22/2022 00:19:29'!
delay

	(Delay forMilliseconds: 100) wait! !
!DataBaseSession methodsFor: 'persistence - private' stamp: 'HAW 5/22/2022 19:29:06'!
objectsOfType: aType

	^ tables at: aType ifAbsent: [ #() ]! !
!DataBaseSession methodsFor: 'persistence - private' stamp: 'HAW 5/22/2022 00:19:29'!
persistAddressesOf: anObjectWithAddresses

	anObjectWithAddresses addresses do: [ :anAddress | self persist: anAddress ]
	! !
!DataBaseSession methodsFor: 'initialization' stamp: 'HAW 5/22/2022 00:19:29'!
initializeFor: aConfiguration

	configuration := aConfiguration.
	tables := Dictionary new.
	id := 0.! !
!DataBaseSession methodsFor: 'id' stamp: 'HAW 5/22/2022 00:19:29'!
newIdFor: anObject

	id := id + 1.
	^id! !
!DataBaseSession methodsFor: 'persistance' stamp: 'HAW 5/22/2022 00:19:29'!
persist: anObject

	| table |

	self delay.
	table := tables at: anObject class ifAbsentPut: [ Set new ].

	self defineIdOf: anObject.
	table add: anObject.

	(anObject isKindOf: Customer) ifTrue: [ self persistAddressesOf: anObject ].! !
!DataBaseSession methodsFor: 'selecting' stamp: 'HAW 5/22/2022 19:29:06'!
select: aCondition ofType: aType

	self delay.
	^(self objectsOfType: aType) select: aCondition ! !
!DataBaseSession methodsFor: 'selecting' stamp: 'HAW 5/22/2022 19:29:06'!
selectAllOfType: aType

	self delay.
	^(self objectsOfType: aType) copy ! !

!classDefinition: 'DataBaseSession class' category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
DataBaseSession class
	instanceVariableNames: ''!

!classDefinition: 'DataBaseSession class' category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
DataBaseSession class
	instanceVariableNames: ''!
!DataBaseSession class methodsFor: 'instance creation' stamp: 'HAW 5/22/2022 00:19:29'!
for: aConfiguration

	^self new initializeFor: aConfiguration! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:11' prior: 50653301!
test01Import

	| numberOfCustomers |
	Customer importCustomers.
	
	numberOfCustomers := 2.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:15' prior: 50653570!
test01Import

	| numberOfCustomers |
	
	Customer importCustomers.
	
	numberOfCustomers := 2.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:04:53' prior: 50653578!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2 ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:05:33' prior: 50653586!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:22:56' prior: 50653595!
test01Import

	| numberOfCustomers session |
	
	Customer importCustomers.
	
	"session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	session close."! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:25:02' prior: 50653608!
test01Import
	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:27:12' prior: 50653621!
test01Import

	self importCustomers.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:27:24'!
importCustomers

| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:28:02' prior: 50653666!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'jgv 11/13/2023 21:25:08'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:29:01' prior: 50653662!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:29:25' prior: 50653753!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:30:29' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:30:29' prior: 50653706!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:31:13' prior: 50653761!
test01Import

	| numberOfCustomers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:31:32' prior: 50653776!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.! !

!methodRemoval: Customer class #importCustomers stamp: 'jgv 11/13/2023 21:25:08'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:03' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:03' prior: 50653822!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:33:10' prior: 50653903!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:38:33' prior: 50653813!
test01Import

	| numberOfCustomers customer customers |
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:38:42' prior: 50653974!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:47:52' prior: 50653939!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:48:57' prior: 50653997!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:49:54' prior: 50654056!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses equals: 2. 
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:50:02' prior: 50654080!
test01Import

	| numberOfCustomers customer customers |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:55:26' prior: 50654105!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.

	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:57:43' prior: 50654130!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.
	self assert: (pepesAddresses anySatisfy: [ :anAddress | anAddress ])
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 20:58:34' prior: 50654157!
test01Import

	| numberOfCustomers customer customers pepesAddresses |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	pepesAddresses := customer addresses.
	self assert: (pepesAddresses anySatisfy: [ :anAddress | anAddress streetName = 'San Martin'])
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:03:50' prior: 50654186!
test01Import

	| numberOfCustomers customer customers pepesAddresses pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:04:00' prior: 50654216!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:06:31' prior: 50654245!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [] ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:07:08' prior: 50654273!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:10:39' prior: 50654302!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:11:02' prior: 50654332!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:11:37' prior: 50654375!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']].
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	self assert:customer addresses includes: pepesFirstAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:14' prior: 50654419!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:35' prior: 50654465!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:14:52' prior: 50654521!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:16:46' prior: 50654577!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	pepesSecondAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:17:24' prior: 50654635!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = '1636'] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = '1122']] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:19:51' prior: 50654695!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = 1636] ] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:26:16'!
FAILURE!

----SNAPSHOT----(13 November 2023 21:26:21) CuisUniversity-CustomerImporter.image priorSource: 10197292!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:26:34'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:26:35'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:27:19' prior: 50654758!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = 1636]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'SanMartin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:27:25'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:30:13'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:30:22'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:30:24'!
FAILURE!

self objectsOfType: aType!

tables at: aType ifAbsent: [ #() ]!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:33:37'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:33:47'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:33:48'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:35:06'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:37:54' prior: 50654021!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth.
			session persist: newAddress].

		line := inputStream nextLine. ].

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:37:59'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:38:08' prior: 50654831!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	someAddress := session select: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress zipCode = 1636]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesFirstAddress := someAddress anyOne.
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:38:11'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:38:20'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:38:21'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:44:54' prior: 50654955!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: '3322'.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: '1636'.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	self assert:customer addresses includes: pepesFirstAddress.
	
	someAddress := session select: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]] ofType: Address.
	self assert: someAddress size equals: 1.
	pepesSecondAddress := someAddress anyOne.
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: '888'.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: '1122'.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	self assert: customer addresses includes: pepesSecondAddress.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:45:05'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:46:24' prior: 50655025!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress someAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: 3322.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: 1636.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	 
	pepesSecondAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]].
	self assert: pepesSecondAddress streetNumber equals: 888.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: 1122.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:46:29'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:46:43' prior: 50654916!
importCustomers

| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth.
			session persist: newAddress].

		line := inputStream nextLine. ].

	inputStream close.! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:46:47'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:46:48'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:50:36' prior: 50655088!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress juansAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: 3322.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: 1636.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	 
	pepesSecondAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]].
	self assert: pepesFirstAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: 888.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: 1122.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'C' and: [aCustomer identificationNumber = '23-25666777-9']]  ofType: Customer.
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: '	Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.
	self assert: customer addresses size equals: 1. 
	
	juansAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Alem' and: [ anAddress zipCode = 1001]].
	self assert: pepesFirstAddress streetName equals: 'Alem'.
	self assert: pepesSecondAddress streetNumber equals: 1122.
	self assert: pepesSecondAddress town equals: 'CABA'.
	self assert: pepesSecondAddress zipCode equals: 1001.
	self assert: pepesSecondAddress province equals: 'CABA'.	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:51:14' prior: 50655183!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress juansAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: 3322.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: 1636.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	 
	pepesSecondAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]].
	self assert: pepesFirstAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: 888.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: 1122.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'C' and: [aCustomer identificationNumber = '23-25666777-9']]  ofType: Customer.
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: '	Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.
	self assert: customer addresses size equals: 1. 
	
	juansAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Alem' and: [ anAddress zipCode = 1001]].
	self assert: juansAddress streetName equals: 'Alem'.
	self assert: juansAddress streetNumber equals: 1122.
	self assert: juansAddress town equals: 'CABA'.
	self assert: juansAddress zipCode equals: 1001.
	self assert: juansAddress province equals: 'CABA'.	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:51:16'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:51:38' prior: 50655265!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress juansAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: 3322.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: 1636.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	 
	pepesSecondAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]].
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: 888.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: 1122.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'C' and: [aCustomer identificationNumber = '23-25666777-9']]  ofType: Customer.
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: '	Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.
	self assert: customer addresses size equals: 1. 
	
	juansAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Alem' and: [ anAddress zipCode = 1001]].
	self assert: juansAddress streetName equals: 'Alem'.
	self assert: juansAddress streetNumber equals: 1122.
	self assert: juansAddress town equals: 'CABA'.
	self assert: juansAddress zipCode equals: 1001.
	self assert: juansAddress province equals: 'CABA'.	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:51:40'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'jgv 11/13/2023 21:51:54' prior: 50655349!
test01Import

	| numberOfCustomers customer customers pepesFirstAddress pepesSecondAddress juansAddress |
	
	self importCustomers.
	
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'D' and: [aCustomer identificationNumber = '22333444']]  ofType: Customer.
	
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	self assert: customer addresses size equals: 2. 
	
	pepesFirstAddress := customer addresses detect: [:anAddress | anAddress streetName = 'San Martin' and: [ anAddress  zipCode = 1636]].
	self assert: pepesFirstAddress streetName equals: 'San Martin'.
	self assert: pepesFirstAddress streetNumber equals: 3322.
	self assert: pepesFirstAddress town equals: 'Olivos'.
	self assert: pepesFirstAddress zipCode equals: 1636.
	self assert: pepesFirstAddress province equals: 'BsAs'.
	
	 
	pepesSecondAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Maipu' and: [ anAddress zipCode = 1122]].
	self assert: pepesSecondAddress streetName equals: 'Maipu'.
	self assert: pepesSecondAddress streetNumber equals: 888.
	self assert: pepesSecondAddress town equals: 'Florida'.
	self assert: pepesSecondAddress zipCode equals: 1122.
	self assert: pepesSecondAddress province equals: 'Buenos Aires'.	
	
	customers := session select: [:aCustomer | aCustomer identificationType = 'C' and: [aCustomer identificationNumber = '23-25666777-9']]  ofType: Customer.
	self assert: customers size equals: 1.
	customer :=  customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.
	self assert: customer addresses size equals: 1. 
	
	juansAddress := customer addresses detect: [:anAddress | anAddress streetName = 'Alem' and: [ anAddress zipCode = 1001]].
	self assert: juansAddress streetName equals: 'Alem'.
	self assert: juansAddress streetNumber equals: 1122.
	self assert: juansAddress town equals: 'CABA'.
	self assert: juansAddress zipCode equals: 1001.
	self assert: juansAddress province equals: 'CABA'.	
	! !

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:51:56'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:52:01'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'jgv 11/13/2023 21:52:02'!
PASSED!

----QUIT----(13 November 2023 21:52:18) CuisUniversity-CustomerImporter.image priorSource: 10341493!